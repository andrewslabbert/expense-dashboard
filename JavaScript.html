<!-- JavaScript.html -->
<script>
    // Feather Icons Initialization (run early)
    try {
        feather.replace();
    } catch (e) {
        console.error("Feather Icons initialization failed:", e);
    }

    // Register DataLabels plugin with Chart.js
    if (typeof Chart !== 'undefined' && typeof ChartDataLabels !== 'undefined') {
         Chart.register(ChartDataLabels);
    } else {
         console.error("Chart.js or ChartDataLabels not loaded before registration attempt.");
    }

    // --- DOM Elements ---
    const prevMonthBtn = document.getElementById('prev-month');
    const nextMonthBtn = document.getElementById('next-month');
    const currentMonthMainDisplay = document.getElementById('current-month-main');
    const currentMonthSubDisplay = document.getElementById('current-month-sub');
    const categoryContent = document.getElementById('category-content'); // Holds list OR details
    const categoryListTitle = document.getElementById('category-list-title'); // Title for container 2
    const totalSpendAmountEl = document.getElementById('total-spend-amount');
    const graphTitleElement = document.getElementById('graph-title'); // Title for container 1
    const listContainerHeader = document.getElementById('list-header'); // Header for container 2
    const graphContainerHeader = document.getElementById('graph-header'); // Header for container 1
    const chartWrapperElement = document.querySelector('.chart-wrapper'); // In container 1
    const insightsPlaceholder = document.querySelector('.insights-placeholder'); // In container 2
    const bodyElement = document.body;
    const sidebar = document.querySelector('.sidebar');
    const toggleButton = document.getElementById('sidebar-toggle-button');

    // --- Sidebar Toggle Logic ---
    function setSidebarState(isExpanded) {
        const toggleIcon = toggleButton ? toggleButton.querySelector('svg.feather') : null;
        if (!bodyElement || !toggleIcon) {
            console.error("Sidebar toggle elements not found.");
            return;
        }
        if (isExpanded) {
            bodyElement.classList.add('sidebar-expanded');
            toggleIcon.setAttribute('data-feather', 'chevrons-left');
            localStorage.setItem('sidebarState', 'expanded');
        } else {
            bodyElement.classList.remove('sidebar-expanded');
            toggleIcon.setAttribute('data-feather', 'chevrons-right');
            localStorage.setItem('sidebarState', 'collapsed');
        }
        // Trigger chart resize after CSS transition
        if (expenseChart && typeof expenseChart.resize === 'function') {
             setTimeout(() => {
                try { expenseChart.resize(); } catch(e) { console.warn("Could not resize chart:", e); }
             }, 350); // Slightly longer than CSS transition (0.3s)
         }
    }

    function initializeSidebar() {
        if (!toggleButton) return;
        toggleButton.addEventListener('click', () => {
            const isCurrentlyExpanded = bodyElement.classList.contains('sidebar-expanded');
            setSidebarState(!isCurrentlyExpanded);
        });
        // Set initial state from localStorage, defaulting to collapsed
        const savedState = localStorage.getItem('sidebarState');
        setSidebarState(savedState === 'expanded');
    }
    // --- End Sidebar Logic ---

    // --- Category Mappings & Icon Helpers ---
    const categoryMappings = {
        // Core Expenses (Example - Expand with YOUR categories)
        'Rent':               { colorVar: '--c1',  iconName: 'home' },
        'Groceries':          { colorVar: '--c2',  iconName: 'shopping-cart' },
        'Fuel':               { colorVar: '--c3',  iconName: 'truck' },
        'Restaurants':        { colorVar: '--c4',  iconName: 'coffee' },
        'Takeaways':          { colorVar: '--c7',  iconName: 'package' },
        'Utilities':          { colorVar: '--c11', iconName: 'zap' },
        'Internet':           { colorVar: '--c12', iconName: 'wifi' },
        'Cellphone':          { colorVar: '--c8',  iconName: 'smartphone' },
        'Donations':          { colorVar: '--c5',  iconName: 'gift' },
        'Tithing':            { colorVar: '--c13', iconName: 'percent' },
        'Insurance':          { colorVar: '--c14', iconName: 'shield' },
        'Clothing & Shoes':   { colorVar: '--c6',  iconName: 'shopping-bag' },
        'Personal Care':      { colorVar: '--c9',  iconName: 'smile' },
        'Entertainment':      { colorVar: '--c15', iconName: 'film' },
        'Sport & Hobbies':    { colorVar: '--c16', iconName: 'activity' },
        'Medical/Pharmacy':   { colorVar: '--c17', iconName: 'heart' },
        'Vehicle Maintenance':{ colorVar: '--c18', iconName: 'tool' },
        'Public Transport':   { colorVar: '--c19', iconName: 'navigation' },
        'Uncategorised':      { colorVar: '--c10', iconName: 'tag' }, // Specific Uncategorised
        // --- Special Definitions ---
        'Other Expenses':     { colorVar: '--text-tertiary', iconName: 'tag', isGroupedCategory: true },
        '__DEFAULT__':        { colorVar: '--text-tertiary', iconName: 'alert-circle' } // Fallback
    };

    // --- DEFINE Day-to-Day Categories for Weekly Insight ---
    const DAY_TO_DAY_CATEGORIES = new Set([ // Using a Set for efficient lookups
        'Groceries', 'Restaurants', 'Takeaways', 'Personal Care', 'Entertainment',
        'Housekeeping', 'Home Improvements', 'Clothing & Shoes', 'Sport & Hobbies',
        'Pharmacy', 'Public Transport', 'Parking', 'Food', 'Alcohol',
        'Other Transport', 'Other Personal & Family'
        // Explicitly EXCLUDED (among others): Fuel, Rent, Tithing, Transfers, Cell C, Spotify, Insurance, Medical Bills, Cash, Uncategorised etc.
    ]);
    const WEEKS_TO_AVERAGE_INSIGHT = 6; // Number of weeks to use for averaging in insights
    // --- End Definition ---

    // --- State ---
    let expenseChart = null;
    let currentViewMode = 'overview'; // 'overview' or 'detail'
    let selectedCategory = null;      // Name of category when in 'detail' mode
    let dashboardData = {};           // Holds raw data { cycleKey: { total, details: { cat: [...] } } }
    let monthKeys = [];               // Sorted array of cycle keys
    let currentMonthIndex = -1;       // Index in monthKeys for the currently displayed cycle
    let currentInsightWeekOffset = 0; // 0 = current week, -1 = last week, etc.

    // --- Helpers, Chart Defaults, Formatting ---
    const getCssVarValue = (varName) => getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
    const formatCurrency = (amount) => {
         const numAmount = Number(amount);
         if (isNaN(numAmount)) return 'R --.--';
         return new Intl.NumberFormat('en-ZA', { style: 'currency', currency: 'ZAR', minimumFractionDigits: 2, maximumFractionDigits: 2 }).format(numAmount);
    };

    function getDisplayPartsForCycleKey(cycleKey) {
        // ... (Keep existing implementation from previous steps) ...
        if (!cycleKey || typeof cycleKey !== 'string') return { main: 'Invalid Key', sub: '' };
        const parts = cycleKey.split('_to_');
        if (parts.length !== 2) return { main: cycleKey, sub: '' };
        try {
            const endDate = new Date(parts[1] + 'T00:00:00Z');
            if (isNaN(endDate.getTime())) throw new Error("Invalid end date");
            const endMonthMain = endDate.toLocaleDateString('en-US', { month: 'short', timeZone: 'UTC' });
            const endYearMain = endDate.getUTCFullYear();
            return { main: `${endMonthMain} ${endYearMain}`, sub: formatCycleKeyForDisplay(cycleKey) };
        } catch (e) { return { main: cycleKey, sub: 'Error' }; }
    }

    function formatCycleKeyForDisplay(cycleKey) {
        // ... (Keep existing implementation from previous steps) ...
        if (!cycleKey || typeof cycleKey !== 'string') return 'Invalid Key';
        const parts = cycleKey.split('_to_');
        if (parts.length !== 2) return cycleKey;
        try {
            const startDate = new Date(parts[0] + 'T00:00:00Z');
            const endDate = new Date(parts[1] + 'T00:00:00Z');
            if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) throw new Error("Invalid date");
            const startMonth = startDate.toLocaleDateString('en-US', { month: 'short', timeZone: 'UTC' });
            const startDay = startDate.getUTCDate();
            const endMonth = endDate.toLocaleDateString('en-US', { month: 'short', timeZone: 'UTC' });
            const endDay = endDate.getUTCDate();
            const displayYear = endDate.getUTCFullYear();
            if (startDate.getUTCFullYear() !== displayYear) {
                return `${startMonth} ${startDay}, ${startDate.getUTCFullYear()} - ${endMonth} ${endDay}, ${displayYear}`;
            } else {
                return `${startMonth} ${startDay} - ${endMonth} ${endDay}, ${displayYear}`;
            }
        } catch (e) { return cycleKey; }
    }

    function setChartDefaults() {
        try {
            Chart.defaults.color = getCssVarValue('--text-secondary');
            Chart.defaults.borderColor = getCssVarValue('--grid-line-color');
            Chart.defaults.font.family = getCssVarValue('--font-family');
            Chart.defaults.font.size = 12;
            Chart.defaults.plugins.tooltip.enabled = false; // Use external tooltip
            Chart.defaults.plugins.datalabels.display = false; // Default off
        } catch (e) { console.error("Error setting Chart defaults:", e); }
    }

    function hexToRGBA(hex, alpha) {
        hex = hex.replace('#', '');
        if (hex.length === 3) { hex = hex[0]+hex[0]+hex[1]+hex[1]+hex[2]+hex[2]; }
        const r = parseInt(hex.substring(0, 2), 16);
        const g = parseInt(hex.substring(2, 4), 16);
        const b = parseInt(hex.substring(4, 6), 16);
        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }

    // --- Data Processing/Calculation Functions ---

    /**
     * Generates data for the Month Graph (historical spending for a category).
     * Handles "Other Expenses" by summing relevant categories.
     */
    function getDataForMonthGraph(categoryName, numMonths = 10) {
        const historicalLabels = [];
        const historicalAmounts = [];
        const backgroundColors = [];
        const fullMonthKeys = []; // Store raw cycle keys for tooltip/clicks
        const historyOpacity = parseFloat(getCssVarValue('--history-bar-opacity')) || 0.45;

        if (!monthKeys.length || currentMonthIndex < 0 || !dashboardData) {
            return { labels: [], datasets: [], fullKeys: [] };
        }

        // Determine color for the selected category
        const mapping = categoryMappings[categoryName] || categoryMappings['__DEFAULT__'];
        const categoryHighlightColorHex = getCssVarValue(mapping.colorVar || '--accent');

        const startIndex = Math.max(0, currentMonthIndex - numMonths + 1);

        // Loop through relevant past cycles (up to the current index)
        for (let i = startIndex; i <= currentMonthIndex; i++) {
            const cycleKey = monthKeys[i];
            const cycleData = dashboardData[cycleKey];
            let categoryDataAmount = 0;

            // Format label (e.g., "Nov '23")
            try {
               const startDate = new Date(cycleKey.split('_to_')[0] + 'T00:00:00Z');
               const startMonthShort = startDate.toLocaleDateString('en-US', { month: 'short', timeZone: 'UTC' });
               const startYearShort = String(startDate.getUTCFullYear()).slice(-2);
               historicalLabels.push(`${startMonthShort} '${startYearShort}`);
            } catch { historicalLabels.push(cycleKey.substring(5, 10)); } // Fallback label

            fullMonthKeys.push(cycleKey); // Store the full key

            // Calculate amount for this cycle
            if (cycleData?.details) {
                if (categoryName === "Other Expenses") {
                    const mappedKeys = Object.keys(categoryMappings).filter(k => k !== '__DEFAULT__' && k !== 'Other Expenses');
                    const detailKeysForCycle = Object.keys(cycleData.details);
                    const otherKeysInCycle = detailKeysForCycle.filter(k => !mappedKeys.includes(k));
                    otherKeysInCycle.forEach(key => {
                         categoryDataAmount += (cycleData.details[key] || []).reduce((sum, item) => sum + (Number(item.amount) || 0), 0);
                    });
                } else {
                    categoryDataAmount = (cycleData.details[categoryName] || []).reduce((sum, item) => sum + (Number(item.amount) || 0), 0);
                }
            }
            historicalAmounts.push(categoryDataAmount);
            backgroundColors.push(hexToRGBA(categoryHighlightColorHex, historyOpacity)); // Use semi-transparent color
        }

historicalLabels.reverse();
historicalAmounts.reverse();
backgroundColors.reverse();
fullMonthKeys.reverse();

        // Return data structured for Chart.js (Reverse to show oldest first on Y-axis if desired, but usually newest at top is better for time series)
        return {
            labels: historicalLabels, // .reverse(), // Usually keep chronological top-to-bottom
            datasets: [{
                label: categoryName,
                data: historicalAmounts, // .reverse(),
                backgroundColor: backgroundColors, // .reverse(),
                borderWidth: 0,
                borderRadius: 4,
                originalColors: backgroundColors.slice(), // Store for highlighting
                highlightColor: categoryHighlightColorHex   // Store solid color
            }],
            fullKeys: fullMonthKeys // .reverse()
        };
    }

    /**
     * Processes data for the Overview State (Category Graph/List).
     * Calculates Top N + Other Expenses for a specific cycle.
     */
    function processCycleDataForDisplay(cycleData, mappings, topN = 9) {
        const displayCategories = [];
        let otherExpensesTotal = 0;
        const allCategoryTotals = {};

        const detailKeysInCycle = cycleData?.details ? Object.keys(cycleData.details) : [];

        // Calculate totals for ALL categories this cycle
        detailKeysInCycle.forEach(categoryName => {
            const totalAmount = (cycleData.details[categoryName] || []).reduce((sum, item) => sum + (Number(item.amount) || 0), 0);
            if (totalAmount > 0) { allCategoryTotals[categoryName] = totalAmount; }
        });

        // Sort all categories by amount
        const sortedCategories = Object.entries(allCategoryTotals)
            .map(([name, amount]) => ({ name, amount }))
            .sort((a, b) => b.amount - a.amount);

        // Determine Top N and group others
        const topNCategoryNames = new Set(sortedCategories.slice(0, topN).map(cat => cat.name));

        sortedCategories.forEach(category => {
            if (topNCategoryNames.has(category.name)) {
                const mapping = mappings[category.name] || mappings['__DEFAULT__'];
                displayCategories.push({
                    name: category.name,
                    amount: category.amount,
                    colorVar: mapping.colorVar,
                    iconName: mapping.iconName
                });
            } else {
                otherExpensesTotal += category.amount;
            }
        });

        // Add "Other Expenses" category if needed
        if (otherExpensesTotal > 0) {
            const otherMapping = mappings['Other Expenses'];
            displayCategories.push({
                name: 'Other Expenses',
                amount: otherExpensesTotal,
                colorVar: otherMapping.colorVar,
                iconName: otherMapping.iconName,
                isGrouped: true
            });
        }

        return { displayCategories }; // Only need the final list for rendering
    }

    /**
     * Calculates average spend for a category over N periods ending at a specific cycle.
     */
    function calculateAverageSpend(categoryName, endCycleKey, numPeriods = 6) {
        // ... (Keep existing implementation - calculates average and difference) ...
        let historicalTotals = [];
        let periodTotalForEndCycle = 0;
        const endCycleIndex = monthKeys.indexOf(endCycleKey);

        if (endCycleIndex === -1 || !dashboardData || Object.keys(dashboardData).length === 0 || !categoryName) {
            return { averageSpend: 0, difference: 0, historicalTotalsCount: 0 };
        }
        const startIndex = Math.max(0, endCycleIndex - numPeriods + 1);

        for (let i = startIndex; i <= endCycleIndex; i++) {
            const cycleKey = monthKeys[i];
            const cycleData = dashboardData[cycleKey];
            let periodTotal = 0;
            if (cycleData?.details) {
                 if (categoryName === "Other Expenses") {
                     const mappedKeys = Object.keys(categoryMappings).filter(k => k !== '__DEFAULT__' && k !== 'Other Expenses');
                     const detailKeysForCycle = Object.keys(cycleData.details);
                     const otherKeysInCycle = detailKeysForCycle.filter(k => !mappedKeys.includes(k));
                     otherKeysInCycle.forEach(key => {
                          periodTotal += (cycleData.details[key] || []).reduce((sum, item) => sum + (Number(item.amount) || 0), 0);
                     });
                 } else {
                     periodTotal = (cycleData.details[categoryName] || []).reduce((sum, item) => sum + (Number(item.amount) || 0), 0);
                 }
            }
            historicalTotals.push(periodTotal);
            if (cycleKey === endCycleKey) { periodTotalForEndCycle = periodTotal; }
        }

        let averageSpend = 0;
        let difference = 0;
        if (historicalTotals.length > 0) {
            const sumOfTotals = historicalTotals.reduce((sum, total) => sum + total, 0);
            averageSpend = sumOfTotals / historicalTotals.length;
            difference = periodTotalForEndCycle - averageSpend;
        }
        return { averageSpend, difference, historicalTotalsCount: historicalTotals.length };
    }
    // --- End Data Processing Functions ---


    // --- Chart Rendering Functions ---

    /**
     * Creates or updates the chart in the graph container based on view mode.
     */
    function createOrUpdateChart(chartDataInput, viewType) { // viewType: 'overviewCategory' or 'detailMonth'
        if (expenseChart) { expenseChart.destroy(); expenseChart = null; }
        // Ensure canvas exists, clear previous messages/canvas
        chartWrapperElement.innerHTML = '<canvas id="expense-chart"></canvas>';
        const ctx = chartWrapperElement.querySelector('#expense-chart')?.getContext('2d');
        if (!ctx) { console.error("Canvas context not found after reset."); return; }

        const textColorPrimary = getCssVarValue('--text-primary');
        const textColorSecondary = getCssVarValue('--text-secondary');
        const gridColor = getCssVarValue('--grid-line-color');
        let data, options;
        const commonDataLabelConfig = {
            display: true, anchor: 'end', align: 'end', offset: 6, padding: 0,
            color: getCssVarValue('--text-secondary'), font: { size: 10, weight: 500 },
            formatter: (value) => (value === 0 ? null : formatCurrency(value))
        };

        if (viewType === 'detailMonth') {
            // Config for Month Graph (History)
            data = chartDataInput; // Expects { labels, datasets, fullKeys }
             const dataset = data.datasets && data.datasets[0] ? data.datasets[0] : { data: [0], label: 'History' };
             options = {
                 responsive: true, maintainAspectRatio: false, indexAxis: 'y',
                 scales: {
                     x: { // Amount axis - minimalist
                         beginAtZero: true,
                         ticks: { display: false }, // Hide numerical labels
                         grid: { display: false }, // Hide grid lines
                         border: { display: false },
                         title: { display: false } // Hide axis title
                     },
                     y: { // Period axis
                         ticks: { color: textColorPrimary, font: { size: 12, weight: 500 }, padding: 10 },
                         grid: { display: false }, border: { display: false }, title: { display: false }
                     }
                 },
                 plugins: {
                     legend: { display: false },
                     tooltip: { enabled: false, external: externalTooltipHandler },
                     datalabels: commonDataLabelConfig // Show amounts next to bars
                 },
                 layout: { padding: { top: 5, bottom: 5, left: 5, right: 45 } }, // More right padding for labels
                 onClick: handleMonthGraphClick
             };
             expenseChart = new Chart(ctx, { type: 'bar', data, options });
             // Store necessary info on the chart instance for interactions
             if (expenseChart && data.fullKeys && dataset.originalColors && dataset.highlightColor) {
                 expenseChart.fullKeys = data.fullKeys;
                 expenseChart.originalColors = dataset.originalColors;
                 expenseChart.highlightColor = dataset.highlightColor;
             } else { console.warn("Missing data needed for history chart interaction."); }

        } else if (viewType === 'overviewCategory') {
            // Config
            const categoriesForChart = chartDataInput; // Expects processedData.displayCategories array
            if (!categoriesForChart || categoriesForChart.length === 0) {
                 chartWrapperElement.innerHTML = `<p class="no-expenses-message">No spending data for this period.</p>`;
                 return; // Don't create chart if no data
            }
             const chartLabels = categoriesForChart.map(cat => cat.name);
             const chartAmounts = categoriesForChart.map(cat => cat.amount);
             const chartBackgroundColors = categoriesForChart.map(cat => getCssVarValue(cat.colorVar || '--accent'));
             const maxAmount = chartAmounts.length > 0 ? Math.max(...chartAmounts.filter(v => !isNaN(v))) : 100;
            data = {
                labels: chartLabels,
                datasets: [{
                    data: chartAmounts, backgroundColor: chartBackgroundColors,
                    borderWidth: 0, borderRadius: 4, barPercentage: 0.8, categoryPercentage: 0.8
                }]
            };
            options = {
                responsive: true, maintainAspectRatio: false, indexAxis: 'y',
                 scales: {
                     x: { // Amount axis
                         beginAtZero: true, suggestedMax: maxAmount * 1.18,
                         ticks: { color: textColorSecondary, font: { size: 11 }, padding: 8 },
                         grid: { color: gridColor, drawTicks: false, borderDash: [3, 3] },
                         border: { display: false },
                         title: { display: true, text: 'Amount (R)', color: textColorSecondary, font: {size: 10, weight: '500'}, padding: {top: 10}}
                     },
                     y: { // Category axis
                         ticks: { color: textColorPrimary, font: { size: 12, weight: 500 }, padding: 12 },
                         grid: { display: false }, border: { display: false }, title: { display: false }
                     }
                 },
                 plugins: {
                     legend: { display: false },
                     tooltip: { enabled: false, external: externalTooltipHandler },
                     datalabels: { display: false } // Usually OFF for overview, rely on axis/tooltip
                 },
                 layout: { padding: { top: 5, bottom: 5, left: 5, right: 15 } },
                 onClick: handleCategoryGraphClick
            };
            expenseChart = new Chart(ctx, { type: 'bar', data, options });
        } else {
             console.error("Unknown chart viewType specified:", viewType);
             chartWrapperElement.innerHTML = `<p class="no-expenses-message" style="color:red;">Chart Error</p>`;
        }
    }

    /** Click handler for the Category Graph (Overview) */
    function handleCategoryGraphClick(event, elements, chart) {
        if (elements.length > 0 && currentViewMode === 'overview') {
            const categoryName = chart.data.labels[elements[0].index];
            if (categoryName) {
                switchToCategoryDetailView(categoryName); // Transition to detail state
            }
        }
     }

    /** Click handler for the Month Graph (Detail) */
    function handleMonthGraphClick(event, elements, chart) {
        if (elements.length > 0 && currentViewMode === 'detail' && chart?.fullKeys && selectedCategory) {
            const elementIndex = elements[0].index;
            const clickedCycleKey = chart.fullKeys[elementIndex];

            if (clickedCycleKey && dashboardData[clickedCycleKey]) {
                highlightHistoryBarForCycle(clickedCycleKey); // Highlight the clicked bar

                // Get transactions for the SELECTED CATEGORY in the CLICKED HISTORICAL CYCLE
                let transactionsForClickedCycle = [];
                const categoryName = selectedCategory;
                const cycleDataHist = dashboardData[clickedCycleKey];

                if (categoryName === "Other Expenses") {
                    if (cycleDataHist?.details) { /* ... logic to sum 'Other' transactions for historical cycle ... */
                        const mappedKeys = Object.keys(categoryMappings).filter(k => k !== '__DEFAULT__' && k !== 'Other Expenses');
                        const allDetailKeysHist = Object.keys(cycleDataHist.details);
                        const otherKeysHist = allDetailKeysHist.filter(key => !mappedKeys.includes(key));
                        otherKeysHist.forEach(key => {
                             const catTransHist = cycleDataHist.details[key]; if (catTransHist) transactionsForClickedCycle.push(...catTransHist);
                        });
                        transactionsForClickedCycle.sort((a,b) => new Date(b.date) - new Date(a.date));
                    }
                } else {
                    transactionsForClickedCycle = (cycleDataHist?.details?.[categoryName] || []).sort((a,b) => new Date(b.date) - new Date(a.date));
                }
                // Update the Transaction List container (#category-content)
                displayTransactionList(categoryName, transactionsForClickedCycle, clickedCycleKey);
            }
        }
     }

    // --- Custom Tooltip ---
    const getOrCreateTooltip = (chart) => {
        // ... (Keep existing implementation - Creates/retrieves the tooltip DOM element) ...
        let tooltipEl = chart.canvas.parentNode.querySelector('div.chartjs-tooltip');
        if (!tooltipEl) {
             tooltipEl = document.createElement('div');
             tooltipEl.classList.add('chartjs-tooltip');
             tooltipEl.style.opacity = 0; // Start hidden
             tooltipEl.style.pointerEvents = 'none';
             tooltipEl.style.position = 'absolute';
             tooltipEl.style.transform = 'translate(-50%, 0)'; // Adjust as needed
             tooltipEl.style.transition = 'all .1s ease';
             const table = document.createElement('table'); table.style.margin = '0px';
             tooltipEl.appendChild(table);
             chart.canvas.parentNode.appendChild(tooltipEl);
        }
        return tooltipEl;
    };
    const externalTooltipHandler = (context) => {
        // ... (Keep existing implementation - Populates tooltip content) ...
         const { chart, tooltip } = context;
         const tooltipEl = getOrCreateTooltip(chart);
         if (tooltip.opacity === 0) { tooltipEl.style.opacity = 0; return; }

         const tableRoot = tooltipEl.querySelector('table');
         tableRoot.innerHTML = ''; // Clear previous content

         if (tooltip.body) {
             const titleLines = tooltip.title || [];
             const bodyLines = tooltip.body.map(b => b.lines);
             const tableHead = document.createElement('thead');
             let displayTitle = titleLines.join(', ');
             const dataIndex = tooltip.dataPoints[0]?.dataIndex;

             // Use full cycle key for history chart titles
             if (currentViewMode === 'detail' && dataIndex !== undefined && chart.fullKeys && chart.fullKeys[dataIndex]) {
                 displayTitle = formatCycleKeyForDisplay(chart.fullKeys[dataIndex]);
             }

             const tr = document.createElement('tr');
             const th = document.createElement('th');
             // Apply styles via CSS if preferred over inline
             th.style.cssText = `font-weight: 600; padding-bottom: 6px; text-align: left; border-bottom: 1px solid var(--border-color); margin-bottom: 6px; display: block; color: var(--text-primary);`;
             th.appendChild(document.createTextNode(displayTitle));
             tr.appendChild(th); tableHead.appendChild(tr);
             tableRoot.appendChild(tableHead);

             const tableBody = document.createElement('tbody');
             bodyLines.forEach((body, i) => {
                 const colors = tooltip.labelColors[i];
                 const span = document.createElement('span'); span.classList.add('tooltip-swatch');
                 span.style.cssText = `background: ${colors.backgroundColor}; border-color: ${colors.borderColor}; border-width: 2px; margin-right: 8px; height: 10px; width: 10px; display: inline-block; border-radius: 3px;`;
                 const tr_body = document.createElement('tr');
                 const td = document.createElement('td'); td.style.cssText = `border-width: 0; padding: 3px 0; display: flex; align-items: center; color: var(--text-primary);`;
                 const amount = tooltip.dataPoints[i]?.parsed?.x ?? tooltip.dataPoints[i]?.parsed?.y ?? 0; // Handle x/y axis
                 td.appendChild(span);
                 // Show category label in overview tooltip
                 if (currentViewMode === 'overview' && tooltip.dataPoints[i]?.label) {
                     td.appendChild(document.createTextNode(`${tooltip.dataPoints[i].label}: `));
                 }
                 td.appendChild(document.createTextNode(formatCurrency(amount)));
                 tr_body.appendChild(td); tableBody.appendChild(tr_body);
             });
             tableRoot.appendChild(tableBody);
         }

         const { offsetLeft: positionX, offsetTop: positionY } = chart.canvas;
         tooltipEl.style.opacity = 1;
         tooltipEl.style.left = positionX + tooltip.caretX + 'px';
         tooltipEl.style.top = positionY + tooltip.caretY + 'px';
         // Adjust tooltip position slightly if needed
         tooltipEl.style.transform = 'translate(-50%, -115%)'; // Move up above cursor
         // Use CSS variables for styling if possible
         tooltipEl.style.background = getCssVarValue('--bg-base');
         tooltipEl.style.borderRadius = '6px';
         tooltipEl.style.color = getCssVarValue('--text-primary');
         tooltipEl.style.padding = '10px 14px';
         tooltipEl.style.boxShadow = '0 4px 12px rgba(0,0,0,0.35)';
         tooltipEl.style.border = `1px solid ${getCssVarValue('--border-color')}`;
         tooltipEl.style.fontFamily = getCssVarValue('--font-family');
         tooltipEl.style.fontSize = '13px';
    };

    /** Highlights the bar corresponding to a specific cycle key in the history chart */
    function highlightHistoryBarForCycle(cycleKeyToHighlight) {
        if (currentViewMode !== 'detail' || !expenseChart?.data?.datasets?.[0] || !expenseChart.fullKeys) return;
        try {
            const dataset = expenseChart.data.datasets[0];
            // Ensure required properties exist before proceeding
            if (!expenseChart.originalColors || !expenseChart.highlightColor) {
                 console.warn("Highlighting skipped: originalColors or highlightColor missing on chart.");
                 return;
            }
            const indexToHighlight = expenseChart.fullKeys.indexOf(cycleKeyToHighlight);
            const newBackgroundColors = expenseChart.originalColors.slice(); // Start with base colors
            if (indexToHighlight !== -1) {
                 newBackgroundColors[indexToHighlight] = expenseChart.highlightColor;
            } else { console.warn(`Highlight: Cycle key "${cycleKeyToHighlight}" not found.`); }
            dataset.backgroundColor = newBackgroundColors;
            expenseChart.update('none'); // Update without animation
        } catch (error) { console.error("Error highlighting history bar:", error); }
    }
    // --- End Chart Rendering ---


    // --- UI Display Functions ---

    /** Renders the category list UL used in the overview state (mainly for mobile) */
    function displayCategoryList(categoriesToShow) {
        let listHTML = '';
        if (!categoriesToShow || categoriesToShow.length === 0) {
            listHTML = `<p class="no-expenses-message">No spending categories found.</p>`;
        } else {
            // IMPORTANT: Add the UL element with the class .category-list
            listHTML = `<ul class="category-list" id="category-list-ul">`;
            categoriesToShow.forEach((category) => {
                const mapping = categoryMappings[category.name] || categoryMappings['__DEFAULT__'];
                listHTML += `<li class="category-item" data-category="${category.name}" style="--inner-color: var(${mapping.colorVar});">
                                 <i data-feather="${mapping.iconName}"></i>
                                 <span class="category-name">${category.name}</span>
                                 <span class="category-amount">${formatCurrency(category.amount)}</span>
                             </li>`;
            });
            listHTML += `</ul>`;
        }
        categoryContent.innerHTML = listHTML; // Render into the dynamic content area
        // Try replacing Feather icons specifically for the category list
        const listElement = categoryContent.querySelector('#category-list-ul');
        if (listElement) {
            try { feather.replace({width: 16, height: 16, class: 'category-icon'}); } // Adjust size/class if needed
            catch(e){ console.error("Feather error replacing icons in category list:", e); }
        }
        // Also replace icons in the newly added insight area if needed
        const insightArea = document.getElementById('insights-area');
        if (insightArea) {
             try {
                 // This should now cover both insight cards
                 feather.replace({width: 18, height: 18});
             }
             catch(e){ console.error("Feather error replacing icons in insights area:", e); }
        }
    }

    /** Renders the transaction list used in the detail state */
    function displayTransactionList(categoryName, transactionsArray, forCycleKey) {
        const expenses = transactionsArray || [];
        const isHistoricalView = forCycleKey !== monthKeys[currentMonthIndex]; // Context for title

        // Update title of Container 2
        categoryListTitle.textContent = categoryName;
        if (isHistoricalView) {
             categoryListTitle.textContent += ` (${formatCycleKeyForDisplay(forCycleKey)})`;
        }

        let transactionsHTML = '';
        if (expenses.length > 0) { expenses.forEach(item => { transactionsHTML += formatTransactionRow(item); }); }
        let currentTotal = expenses.reduce((sum, item) => sum + (Number(item.amount) || 0), 0);

        // Calculate Average based on the cycle being displayed
        const avgData = calculateAverageSpend(categoryName, forCycleKey, 6); // Use forCycleKey
        let averageRowHTML = '';
         if (avgData.averageSpend > 0) {
            let diffText = ''; let diffClass = '';
            if (Math.abs(avgData.difference) > 0.01) {
                diffText = `(${avgData.difference >= 0 ? '+' : ''}${formatCurrency(avgData.difference)})`;
                diffClass = avgData.difference >= 0 ? 'positive' : 'negative';
            }
            averageRowHTML = `
                <div class="details-average-row">
                    <span class="average-label">Avg. (vs ${avgData.historicalTotalsCount} Periods)</span>
                    <span class="average-value">
                        ${formatCurrency(avgData.averageSpend)}
                        ${diffText ? `<span class="average-diff ${diffClass}">${diffText}</span>` : ''}
                    </span>
                </div>`;
         }

        // IMPORTANT: Add the wrapper div with class .category-details
        let detailsHTML = `
            <div class="category-details">
                <div class="transactions-scroll-wrapper">
                    ${expenses.length > 0 ? transactionsHTML : `<p class="no-expenses-message">No expenses for ${categoryName} in period ${formatCycleKeyForDisplay(forCycleKey)}.</p>`}
                </div>
                ${expenses.length > 0 ? `
                    <div class="details-total-row"><span>Total</span><span>${formatCurrency(currentTotal)}</span></div>
                    ${averageRowHTML}
                ` : ''}
            </div>`;

        categoryContent.innerHTML = detailsHTML; // Render into the dynamic content area
    }

    /** Formats a single transaction row */
    function formatTransactionRow(item) {
        const originalDescription = item.description || 'N/A';
        let displayDate = item.date ? new Date(item.date + 'T00:00:00Z').toLocaleDateString('en-US', { month: 'short', day: 'numeric', timeZone: 'UTC' }) : '---';
        // Basic cleaning example - remove card numbers in parenthesis
        let displayDescription = originalDescription.replace(/\s*\(Card\s*\d+\)\s*/i, '').trim();
        if (displayDescription === '' && originalDescription !== 'N/A') { displayDescription = '[Details]'; } // Placeholder if cleaning removed everything

        return `<div class="transaction-list-item">
                    <div class="transaction-left-col">
                        <span class="transaction-date-short">${displayDate}</span>
                        <span class="transaction-description-short" title="${originalDescription}">${displayDescription}</span>
                        <!-- Optional location: ${item.location ? `<span class="transaction-location-inline">${item.location}</span>` : ''} -->
                    </div>
                    <span class="transaction-amount-short">${formatCurrency(item.amount)}</span>
                </div>`;
    }
    // --- End UI Display Functions ---


    // --- Back Button Logic ---
    function addBackButton(headerElement, buttonId, onClickHandler) {
        removeBackButton(headerElement, buttonId); // Prevent duplicates
        const titleElement = headerElement.querySelector('.container-title');
        if (!titleElement) return; // Should not happen
        const backButton = document.createElement('button');
        backButton.id = buttonId;
        backButton.className = 'back-button-header';
        backButton.innerHTML = `<i data-feather="arrow-left"></i>Back`;
        backButton.addEventListener('click', onClickHandler);
        headerElement.insertBefore(backButton, titleElement); // Add button before title
        try { feather.replace({ width: 15, height: 15 }); } catch(e) { console.error("Feather error on back button:", e); }
    }
    function removeBackButton(headerElement, buttonId) {
        const button = headerElement.querySelector(`#${buttonId}`);
        if (button) button.remove();
    }
    /** Handler for ALL back button clicks */
    function handleBackButtonClick() {
        switchToOverviewView(); // Always returns to the main overview
    }
    // --- End Back Button Logic ---

    // --- End Data Processing Functions ---

    // --- Weekly Calculation Helper Functions ---

    /**
     * Gets the date of the Monday for the week containing the given date.
     * @param {Date} date The input date.
     * @returns {Date} A new Date object representing midnight UTC on the Monday of that week.
     */
    function getMondayOfWeek(date) {
        const dt = new Date(date); // Clone
        const day = dt.getUTCDay(); // 0=Sunday, 1=Monday,...
        const diff = dt.getUTCDate() - day + (day === 0 ? -6 : 1); // Adjust when Sunday
        return new Date(Date.UTC(dt.getUTCFullYear(), dt.getUTCMonth(), diff));
    }

    /**
     * Calculates the start (Monday) and end (Sunday) dates for the week containing the given date.
     * @param {Date} targetDate The date for which to find the week range. Defaults to today.
     * @param {number} weekOffset 0 for current week, -1 for previous week, etc.
     * @returns {{start: Date, end: Date, rangeString: string}} Object with start/end Date objects (UTC Midnight) and a display string.
     */
    function getWeekDateRange(targetDate = new Date(), weekOffset = 0) {
        const date = new Date(targetDate); // Clone to avoid modifying original
        date.setDate(date.getDate() + (weekOffset * 7)); // Adjust to the target week

        const dayOfWeek = date.getDay(); // 0=Sunday, 1=Monday, ..., 6=Saturday
        const diffToMonday = dayOfWeek === 0 ? -6 : 1 - dayOfWeek; // Calculate days to subtract to get to Monday

        const weekStart = new Date(date);
        weekStart.setDate(date.getDate() + diffToMonday);
        weekStart.setUTCHours(0, 0, 0, 0); // Set to UTC midnight

        const weekEnd = new Date(weekStart);
        weekEnd.setDate(weekStart.getDate() + 6); // Sunday is 6 days after Monday
        weekEnd.setUTCHours(23, 59, 59, 999); // End of Sunday UTC

        // For filtering, we need UTC midnight start and *beginning* of the day *after* Sunday
        const filterStart = new Date(Date.UTC(weekStart.getUTCFullYear(), weekStart.getUTCMonth(), weekStart.getUTCDate()));
        const filterEnd = new Date(Date.UTC(weekEnd.getUTCFullYear(), weekEnd.getUTCMonth(), weekEnd.getUTCDate() + 1)); // Day after Sunday 00:00 UTC

        // Format range string (e.g., "Apr 15 - Apr 21")
        const options = { month: 'short', day: 'numeric', timeZone: 'UTC' };
        const rangeString = `${weekStart.toLocaleDateString('en-US', options)} - ${weekEnd.toLocaleDateString('en-US', options)}`;

        return { start: filterStart, end: filterEnd, rangeString: rangeString };
    }

     /**
     * Filters transactions from the dashboard data for a specific week and included categories.
     * @param {Date} weekStartDate - The start date of the week (UTC Midnight, Monday).
     * @param {Date} weekEndDate - The end date for filtering (UTC Midnight, day AFTER Sunday).
     * @param {Set<string>} includedCategories - A Set containing the names of categories to include.
     * @returns {Array<Object>} An array of transaction objects matching the criteria.
     */
    function filterTransactionsByWeekAndCategory(weekStartDate, weekEndDate, includedCategories) {
        const relevantTransactions = [];

        // Iterate through cycles that *might* overlap with the week
        // A simple approach: check cycles around the current one. Could be optimized.
        const currentCycleKey = monthKeys[currentMonthIndex];
        const currentCycleIndexChecked = monthKeys.indexOf(currentCycleKey);
        const indicesToCheck = new Set();
        if (currentCycleIndexChecked !== -1) {
             indicesToCheck.add(currentCycleIndexChecked);
             if (currentCycleIndexChecked > 0) indicesToCheck.add(currentCycleIndexChecked - 1); // Check previous cycle too
             if (currentCycleIndexChecked < monthKeys.length - 1) indicesToCheck.add(currentCycleIndexChecked + 1); // Check next cycle too
        } else {
             // Fallback if current cycle isn't found? Maybe check last few cycles?
             // For now, only check current if found.
             console.warn("Current cycle index not found for weekly filtering.");
             // return []; // Or try checking the last cycle
             if (monthKeys.length > 0) indicesToCheck.add(monthKeys.length - 1);
        }


        indicesToCheck.forEach(idx => {
            const cycleKey = monthKeys[idx];
            const cycleData = dashboardData[cycleKey];
            if (cycleData && cycleData.details) {
                for (const category in cycleData.details) {
                    if (includedCategories.has(category)) { // Check if the category is in our Day-to-Day list
                        cycleData.details[category].forEach(tx => {
                            try {
                                const txDate = new Date(tx.date + 'T00:00:00Z'); // Ensure comparison is UTC
                                if (txDate >= weekStartDate && txDate < weekEndDate) {
                                    relevantTransactions.push(tx);
                                }
                            } catch (e) {
                                console.warn(`Skipping transaction due to date parse error: ${tx.date}`, e);
                            }
                        });
                    }
                }
            }
        });

        return relevantTransactions;
    }


    /**
     * Calculates the total spending for the target week and the week before it,
     * based on a week offset from today.
     * @param {number} weekOffset - 0 for current week, -1 for previous, etc.
     * @returns {{targetWeekTotal: number, previousToTargetWeekTotal: number, difference: number, percentageChange: number, targetWeekRange: string}}
     */
    function calculateWeeklyTotals(weekOffset = 0) {
        const today = new Date(); // Base calculations relative to today

        // Get the date range for the week we actually want to display
        const targetWeek = getWeekDateRange(today, weekOffset);
        // Get the date range for the week *before* the target week for comparison
        const previousToTargetWeek = getWeekDateRange(today, weekOffset - 1);

        // Filter transactions for both weeks
        const targetWeekTxs = filterTransactionsByWeekAndCategory(targetWeek.start, targetWeek.end, DAY_TO_DAY_CATEGORIES);
        const previousToTargetWeekTxs = filterTransactionsByWeekAndCategory(previousToTargetWeek.start, previousToTargetWeek.end, DAY_TO_DAY_CATEGORIES);

        // Calculate totals
        const targetWeekTotal = targetWeekTxs.reduce((sum, tx) => sum + (Number(tx.amount) || 0), 0);
        const previousToTargetWeekTotal = previousToTargetWeekTxs.reduce((sum, tx) => sum + (Number(tx.amount) || 0), 0);

        // Calculate difference and percentage change
        const difference = targetWeekTotal - previousToTargetWeekTotal;
        let percentageChange = 0;
        if (previousToTargetWeekTotal !== 0) {
            percentageChange = (difference / previousToTargetWeekTotal) * 100;
        } else if (targetWeekTotal > 0) {
            percentageChange = 100; // Indicate increase if previous was 0 and current > 0
        }

        return {
            targetWeekTotal,
            previousToTargetWeekTotal,
            difference,
            percentageChange,
            targetWeekRange: targetWeek.rangeString, // Use the range of the displayed week
            previousWeekRange: previousToTargetWeek.rangeString // Keep for potential tooltip/debug
        };
    }

    /**
     * Calculates the average "Day-to-Day" spending over the N weeks preceding a target end date.
     * @param {Date} targetEndDate - The end date (exclusive) of the period *before* the average calculation starts. Usually the start date of the week being displayed.
     * @param {number} numWeeks - The number of preceding weeks to average.
     * @returns {{ averageSpend: number, weeksCount: number }}
     */
    function calculateAverageWeeklyVariableSpend(targetEndDate, numWeeks) {
        let totalSpend = 0;
        let weeksCount = 0;
        const today = new Date(targetEndDate); // Start calculations relative to the end date provided

        for (let i = 1; i <= numWeeks; i++) {
            // Get the date range for each preceding week (-1, -2, ... -numWeeks)
            const historicalWeek = getWeekDateRange(today, -i); // Offset relative to targetEndDate's week start

            // Filter transactions for that historical week
            const historicalWeekTxs = filterTransactionsByWeekAndCategory(
                historicalWeek.start,
                historicalWeek.end,
                DAY_TO_DAY_CATEGORIES
            );

            // Add this week's total to the sum
            const weekTotal = historicalWeekTxs.reduce((sum, tx) => sum + (Number(tx.amount) || 0), 0);
            totalSpend += weekTotal;
            weeksCount++; // Count how many weeks we actually summed (might be less than numWeeks if data is limited)
        }

        const averageSpend = weeksCount > 0 ? totalSpend / weeksCount : 0;
        return { averageSpend, weeksCount };
    }

    // --- End Weekly Calculation Helper Functions ---

    // --- Function to Update ONLY the Weekly Insight Card ---
    function updateWeeklyInsightCard() {
        if (!dashboardData || monthKeys.length === 0) return; // Need data loaded

        // 1. Calculate totals for the target week (based on offset)
        const targetWeekData = calculateWeeklyTotals(currentInsightWeekOffset);
        const targetWeekTotal = targetWeekData.targetWeekTotal;
        const targetWeekRange = targetWeekData.targetWeekRange;

        // 2. Calculate the average of the N weeks *before* the target week
        const targetWeekStartDate = getWeekDateRange(new Date(), currentInsightWeekOffset).start; // Get start date of the displayed week
        const avgData = calculateAverageWeeklyVariableSpend(targetWeekStartDate, WEEKS_TO_AVERAGE_INSIGHT);
        const averageSpend = avgData.averageSpend;
        const avgWeeksCount = avgData.weeksCount;


        // 3. Get DOM elements
        const weeklyValueEl = document.getElementById('weekly-dtd-value');
        const weeklyCompEl = document.getElementById('weekly-dtd-comparison');
        const weeklyRangeEl = document.getElementById('weekly-dtd-range'); // Now using span in footer
        const nextButton = document.getElementById('next-insight-week');
        const prevButton = document.getElementById('prev-insight-week'); // Get prev button too

        // 4. Update the displayed values
        if (weeklyValueEl) weeklyValueEl.textContent = formatCurrency(targetWeekTotal);
        if (weeklyRangeEl) weeklyRangeEl.textContent = `Week: ${targetWeekRange}`; // Display the range of the *selected* week

        if (weeklyCompEl) {
            let comparisonText = `vs Avg: ${formatCurrency(averageSpend)}`;
            let diffText = '';
            let diffClass = '';

            if (averageSpend > 0 || targetWeekTotal > 0) { // Only calculate diff if there's something to compare
                 const difference = targetWeekTotal - averageSpend;
                 let percentageChange = 0;
                 if (averageSpend !== 0) {
                     percentageChange = (difference / averageSpend) * 100;
                 } else if (targetWeekTotal > 0) {
                     percentageChange = 100; // Or Infinity? 100% increase might be clearer
                 }

                 // Only show diff text if difference is meaningful
                 if (Math.abs(difference) >= 0.01) {
                     diffClass = difference > 0 ? 'negative' : 'positive'; // Swapped: positive is now when spending less (negative diff)
                     diffText = `<span class="insight-diff ${diffClass}">
                                    (${difference > 0 ? '+' : ''}${formatCurrency(difference)},
                                     ${percentageChange.toFixed(0)}%)
                                  </span>`;
                     comparisonText += ` ${diffText}`;
                 }
            }
            weeklyCompEl.innerHTML = comparisonText;
        }

        // 5. Update button states
        if (nextButton) {
            nextButton.disabled = (currentInsightWeekOffset >= 0); // Disable if viewing current week or future
        }
         // Optional: Disable prev button if you hit the limit of your data? Requires more logic. For now, always enabled.
         if (prevButton) {
             prevButton.disabled = false; // Keep enabled for now
         }


         // 6. Refresh icons (just in case)
         const cardHeader = document.querySelector('#weekly-dtd-insight .insight-card-header');
         if(cardHeader) {
            try { feather.replace({ width: 18, height: 18 }); } catch(e){}
         }
    }
    // --- End Weekly Insight Card Update Function ---

    // --- Core State Change Functions ---

    /** Switches UI to the Overview State */
    function switchToOverviewView() {
        console.log("Switching to Overview View");
        currentViewMode = 'overview';
        selectedCategory = null;
        bodyElement.classList.remove('detail-view-active'); // Core state change

        // Clean up UI elements from detail view
        removeBackButton(listContainerHeader, 'back-to-list-header');
        removeBackButton(graphContainerHeader, 'back-to-graph-header');

        // Trigger a full UI update for the current cycle in overview mode
        updateDashboardUI(monthKeys[currentMonthIndex]);
    }

    /** Switches UI to the Detail State for a selected category */
    function switchToCategoryDetailView(categoryName) {
        console.log(`Switching to Detail View for: ${categoryName}`);
        const currentCycleKey = monthKeys[currentMonthIndex];
        const cycleData = dashboardData[currentCycleKey];
        if (!cycleData) { console.error("DetailView: No data for current cycle:", currentCycleKey); return; }

        currentViewMode = 'detail';
        selectedCategory = categoryName;
        bodyElement.classList.add('detail-view-active'); // Core state change

        // --- Render Container 1: Month Graph ---
        graphTitleElement.textContent = categoryName; // Update title
        const historyData = getDataForMonthGraph(categoryName, 10);
        createOrUpdateChart(historyData, 'detailMonth');
        // Highlight the current cycle's bar initially
        requestAnimationFrame(() => { highlightHistoryBarForCycle(currentCycleKey); });

        // --- Render Container 2: Transaction List (for current cycle) ---
        let transactionsToShow = [];
         if (categoryName === "Other Expenses") {
             if (cycleData?.details) { /* ... logic to sum 'Other' transactions for *current* cycle ... */
                const mappedKeys = Object.keys(categoryMappings).filter(k => k !== '__DEFAULT__' && k !== 'Other Expenses');
                const allDetailKeys = Object.keys(cycleData.details);
                const otherKeys = allDetailKeys.filter(key => !mappedKeys.includes(key));
                otherKeys.forEach(key => { const tx = cycleData.details[key]; if (tx) transactionsToShow.push(...tx); });
                transactionsToShow.sort((a,b)=> new Date(b.date) - new Date(a.date));
             }
         } else {
             transactionsToShow = (cycleData?.details?.[categoryName] || []).sort((a,b)=> new Date(b.date) - new Date(a.date));
         }
        displayTransactionList(categoryName, transactionsToShow, currentCycleKey);

        // --- Add Back Buttons ---
        addBackButton(listContainerHeader, 'back-to-list-header', handleBackButtonClick);
        addBackButton(graphContainerHeader, 'back-to-graph-header', handleBackButtonClick);
    }

    /** Main function to update UI based on current state and cycle */
    function updateDashboardUI(cycleKey) {
        if (!cycleKey || !dashboardData || !dashboardData[cycleKey]) {
             console.warn(`UpdateDashboardUI: Invalid cycleKey or no data for ${cycleKey}. Attempting recovery or showing error.`);
             // Potentially show an error state or default to last known good state/index
             // For now, just log and potentially exit or clear UI
             onDataLoadError(new Error(`Data not found for period ${cycleKey}`)); // Or a gentler message
             return;
        }

        console.log(`Updating UI for Cycle: ${cycleKey}, Mode: ${currentViewMode}`);
        const rawCycleData = dashboardData[cycleKey];

        // --- Update Header (Always) ---
        const displayParts = getDisplayPartsForCycleKey(cycleKey);
        currentMonthMainDisplay.textContent = displayParts.main;
        currentMonthSubDisplay.textContent = displayParts.sub;
        totalSpendAmountEl.textContent = formatCurrency(rawCycleData?.total || 0);
        prevMonthBtn.disabled = (currentMonthIndex <= 0);
        nextMonthBtn.disabled = (currentMonthIndex >= monthKeys.length - 1);

        // --- Handle Case: No Spending Data for this specific cycle ---
         if (!rawCycleData || !rawCycleData.details || Object.keys(rawCycleData.details).length === 0) {
            console.log(`No spending details found for cycle: ${cycleKey}`);
            if (currentViewMode === 'overview') {
                graphTitleElement.textContent = "Spending by Category";
                categoryListTitle.textContent = "Categories / Insights";
                chartWrapperElement.innerHTML = `<p class="no-expenses-message">No spending data.</p>`;
                categoryContent.innerHTML = `<p class="no-expenses-message">No spending data.</p>`; // Clear list/details
            } else if (currentViewMode === 'detail' && selectedCategory) {
                graphTitleElement.textContent = selectedCategory; // Keep history title
                categoryListTitle.textContent = selectedCategory;
                 // Still show history graph (might have past data), but show no transactions
                const historyData = getDataForMonthGraph(selectedCategory, 10);
                createOrUpdateChart(historyData, 'detailMonth');
                requestAnimationFrame(() => { highlightHistoryBarForCycle(cycleKey); }); // Highlight non-existent bar gracefully
                categoryContent.innerHTML = `<p class="no-expenses-message">No spending for ${selectedCategory} in this period.</p>`; // Clear list/details
            }
             if (expenseChart && viewType !== 'detailMonth') { expenseChart.destroy(); expenseChart = null; } // Clear overview chart if needed
            return;
         }


        // --- Render based on View Mode ---
        if (currentViewMode === 'overview') {
            // Ensure correct body class and no back buttons
            bodyElement.classList.remove('detail-view-active');
            removeBackButton(listContainerHeader, 'back-to-list-header');
            removeBackButton(graphContainerHeader, 'back-to-graph-header');

            // Reset titles
            graphTitleElement.textContent = "Spending by Category";
            categoryListTitle.textContent = "Categories / Insights";

            // Process data for overview
            const processedData = processCycleDataForDisplay(rawCycleData, categoryMappings, 9);

            // Render Container 1: Category Graph
            createOrUpdateChart(processedData.displayCategories, 'overviewCategory');

            // Render Container 2: Category List (will be hidden on desktop by CSS)
            displayCategoryList(processedData.displayCategories);
            // Insights placeholder visibility is handled by CSS based on screen size and body class

            // --- Update the Weekly Insight Card ---
            // Reset offset to 0 whenever the main monthly view changes
            // currentInsightWeekOffset = 0; // Optional: Reset week view on month change? Or keep it where user left it? Let's keep it for now.
            updateWeeklyInsightCard();
            // --- End Weekly Insight Card Update ---

        } else if (currentViewMode === 'detail') {
            // Ensure correct body class and add back buttons
            bodyElement.classList.add('detail-view-active');
            addBackButton(listContainerHeader, 'back-to-list-header', handleBackButtonClick);
            addBackButton(graphContainerHeader, 'back-to-graph-header', handleBackButtonClick);

            if (!selectedCategory) { // Safety check
                 console.error("Detail mode update requested but no selected category!");
                 switchToOverviewView(); return;
            }

            // Render Container 1: Month Graph (History)
            graphTitleElement.textContent = selectedCategory; // Set title
            const historyData = getDataForMonthGraph(selectedCategory, 10);
            createOrUpdateChart(historyData, 'detailMonth');
            // Highlight the bar for the *current* cycle
            requestAnimationFrame(() => { highlightHistoryBarForCycle(cycleKey); });

            // Render Container 2: Transaction List (for the *current* cycle)
            let transactionsToShow = [];
             if (selectedCategory === "Other Expenses") {
                  if (rawCycleData?.details) { /* ... logic to sum 'Other' transactions for *current* cycle ... */
                    const mappedKeys = Object.keys(categoryMappings).filter(k => k !== '__DEFAULT__' && k !== 'Other Expenses');
                    const allDetailKeys = Object.keys(rawCycleData.details);
                    const otherKeys = allDetailKeys.filter(key => !mappedKeys.includes(key));
                    otherKeys.forEach(key => { const tx = rawCycleData.details[key]; if (tx) transactionsToShow.push(...tx); });
                    transactionsToShow.sort((a,b)=> new Date(b.date) - new Date(a.date));
                  }
             } else {
                 transactionsToShow = (rawCycleData?.details?.[selectedCategory] || []).sort((a,b)=> new Date(b.date) - new Date(a.date));
             }
            displayTransactionList(selectedCategory, transactionsToShow, cycleKey);
        }
    }
    // --- End Core State Change Functions ---


    // --- Event Handlers ---

    /** Click listener for items in the category list (delegated to #category-content) */
    function handleCategoryListItemClick(event) {
        // Only trigger if in overview mode and clicking an actual item
        if (currentViewMode !== 'overview') return;
        const categoryItem = event.target.closest('.category-item');
        if (!categoryItem) return;

        const category = categoryItem.dataset.category;
        if (category) {
            switchToCategoryDetailView(category);
        }
    }

    /** Month Navigation */
    prevMonthBtn.addEventListener('click', () => {
        if (currentMonthIndex > 0) {
            currentMonthIndex--;
            updateDashboardUI(monthKeys[currentMonthIndex]); // Single update function handles state
        }
    });
    nextMonthBtn.addEventListener('click', () => {
        if (currentMonthIndex < monthKeys.length - 1) {
            currentMonthIndex++;
            updateDashboardUI(monthKeys[currentMonthIndex]); // Single update function handles state
        }
    });
    // --- End Event Handlers ---


    // --- Data Loading & Error Handling ---
    function onDataLoaded(data) {
         console.log("Data received from server:", data);
         if (data.error) {
             onDataLoadError(new Error(data.error)); return;
         }
         if (Object.keys(data).length === 0) {
             onDataLoadError(new Error("No expense data found in the sheet.")); return;
         }

         dashboardData = data;
         monthKeys = Object.keys(dashboardData).sort(); // Ensure chronological order

         if (monthKeys.length > 0) {
             currentMonthIndex = monthKeys.length - 1; // Start at most recent
             switchToOverviewView(); // <<<<< INITIAL STATE SETTER
         } else {
             onDataLoadError(new Error("No valid expense data cycles found."));
         }
         // Re-run feather after potential dynamic content changes (though maybe not needed here)
         // try { feather.replace(); } catch (e) {}
     }

    function onDataLoadError(error) {
         console.error("Error loading dashboard data:", error);
         currentMonthMainDisplay.textContent = "Error";
         currentMonthSubDisplay.textContent = "Failed to load";
         totalSpendAmountEl.textContent = "Error";
         chartWrapperElement.innerHTML = `<p class="no-expenses-message" style="color: #e15759;">Failed to load data.</p>`;
         categoryContent.innerHTML = `<p class="no-expenses-message" style="color: #e15759;">${error.message}. Check logs.</p>`;
         if (expenseChart) { expenseChart.destroy(); expenseChart = null; }
         prevMonthBtn.disabled = true;
         nextMonthBtn.disabled = true;
         // Ensure detail view class is removed on error
         bodyElement.classList.remove('detail-view-active');
     }
    // --- End Data Loading ---


    // --- Initialize ---
    document.addEventListener('DOMContentLoaded', () => {
         setChartDefaults();
         initializeSidebar(); // Initialize sidebar state/toggle

         // Set initial loading states
         currentMonthMainDisplay.textContent = "Loading...";
         currentMonthSubDisplay.textContent = "";
         totalSpendAmountEl.textContent = "---";
         chartWrapperElement.innerHTML = `<p class="no-expenses-message">Loading chart...</p>`;
         categoryContent.innerHTML = "<p class='no-expenses-message'>Loading categories...</p>";

         // Attach listener for category list clicks using Delegation
         if (categoryContent) {
             categoryContent.addEventListener('click', handleCategoryListItemClick);
         } else { console.error("Could not find #category-content element."); }

         // Fetch data from backend
         google.script.run
             .withSuccessHandler(onDataLoaded)
             .withFailureHandler(onDataLoadError)
             .getDataForDashboard();

         // --- ADD Event Listeners for Insight Week Navigation ---
         const prevInsightWeekBtn = document.getElementById('prev-insight-week');
         const nextInsightWeekBtn = document.getElementById('next-insight-week');

         if (prevInsightWeekBtn) {
             prevInsightWeekBtn.addEventListener('click', () => {
                 currentInsightWeekOffset--; // Go back one week
                 updateWeeklyInsightCard(); // Update only the card
             });
         } else { console.error("Previous Insight Week button not found"); }

         if (nextInsightWeekBtn) {
             nextInsightWeekBtn.addEventListener('click', () => {
                 if (currentInsightWeekOffset < 0) { // Only allow going forward if not at current week
                     currentInsightWeekOffset++;
                     updateWeeklyInsightCard(); // Update only the card
                 }
             });
         } else { console.error("Next Insight Week button not found"); }
         // --- End Insight Week Navigation Listeners ---

     });
    // --- End Initialize ---

</script>
<!-- End JavaScript.html -->